#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Jul 11 14:11:02 2019

@author: robertmckenzie

This script takes a directory as input and returns a list of statistics
generated by the statistics engine for each image in the directory.
"""
import imagestatsengine as ise
from PIL import Image

import os
import sys
import time

import multiprocessing as mp

"""
Gets image statistics for a region of a directory and sends them to the
pipe to be written to the data file. This facilitates multiprocessing.

directory: ENCODED directory to be processed.
dirlist: os.listdir(directory), passed separately to ensure each process
  gets the same list order.
startind, endind: boundaries of the region to be processed.
"""
def process_directory_region(directory, dirlist, startind, endind, outpipe):
    for i in range(startind, endind):
        filename = os.fsdecode(dirlist[i])
        if (filename.endswith(".jpg") or
            filename.endswith(".jpeg") or
            filename.endswith(".png")):
            
            im = Image.open(os.fsdecode(directory) + "/" + filename)
            try:
                outpipe[0].send((filename, ise.get_image_stats(im)))
            except TypeError:
                print("Type Error on " + filename)
                
"""
Receives statistics from other processes and writes them to the data file.

outpipe: mp.Pipe() used to get data from other processes.
datafile: File to write to.
dirsize: Optional. If passed, the function will update the console each time
it processes 5% of the directory.
"""
def write_from_pipe(outpipe, datafile, dirsize = None):
    count = 0
    percent_done = 0
    five_percent = -1
    if not dirsize == None:
        print("Progress:\n0%")
        five_percent = int(dirsize / 20)
    while outpipe[1].poll(10):
        try:
            stat = outpipe[1].recv()
            datafile.write("FILENAME " + stat[0] + "\n!" + ise.stats_to_string(stat[1]) + "\n\n")
            count += 1
            if count == five_percent:
                percent_done += 5
                count = 0
                print(str(percent_done) + "%")
        except EOFError:
            return

"""
Uses multiprocessing to get image statistics for an entire directory.

directory_dec: Directory to be processed, in decoded string form.
outfile: Data file, currently just .txt, to be written to.
"""
def process_full_directory(directory_dec, outfile, timer = False):
    directory_enc = os.fsencode(directory_dec)
    dir_listed = os.listdir(directory_enc)
    dir_size = len(dir_listed)
    
    """
    We use all processing cores but one to process the directory, and
    the last core to write to the file. If only one core is available,
    we use it for both.
    """
    outpipe = mp.Pipe()
    n_processes = max(1, mp.cpu_count() - 1)
    cpuallocsize = int(dir_size / n_processes)
    cpuindices = []
    for x in range(n_processes):
        cpuindices.append([x * cpuallocsize, (x + 1) * cpuallocsize])
    cpuindices[n_processes - 1][1] = dir_size
    
    procs = []
    for i in range(n_processes):
        procs.append(mp.Process(target = process_directory_region, args = 
                                (directory_enc,dir_listed, cpuindices[i][0],
                                 cpuindices[i][1], outpipe)))
    pipe_proc = mp.Process(target = write_from_pipe, args = (outpipe, outfile, dir_size))
    pipe_proc.start()
    
    start_time = time.time()
    
    for p in procs:
        p.start()
    for p in procs:
        p.join()
    outpipe[1].close()
    pipe_proc.join()
    elapsed_time = time.time() - start_time
    
    if timer:
        print("Done in " + str(elapsed_time) + " seconds.")
        
"""
Code to be executed if this script is run as the main. It requires two
arguments: the directory to be processed, and the name of the file to
be written to.
"""
if __name__ == "__main__":
    args = sys.argv
    print(args)
    timer = False
    if(len(args) > 3 and args[3] == "keeptime"):
        timer = True
    try:
        x = os.fsencode(args[1])
        os.listdir(x)
        y = args[2]
    except:
        print("Invalid arguments. Exiting.")
        sys.exit()
    
    datafile = open(args[2], "a+")
    
    process_full_directory(args[1], datafile, timer)